import asyncio
import json
import time
import math
import csv
import sys
from collections import deque, defaultdict
from dataclasses import dataclass, field
from typing import Dict, Deque, Tuple

import aiohttp
import numpy as np
from scipy.stats import entropy as shannon_entropy

"""
Ù…Ø­Ø±Ù‘Ùƒ "Quantum Flow Sniper" Ø¨Ù†Ø³Ø®Ø© Ù…Ø¤Ø³Ø³ÙŠØ©:
- ÙŠØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ ØªØ­Ù„ÙŠÙ„ ÙÙŠØ²ÙŠØ§Ø¦ÙŠ Ø¥Ø­ØµØ§Ø¦ÙŠ (Hurst, Shannon Entropy, Kalman Filter).
- ÙŠØ³ØªØ®Ø¯Ù… ØªØ¯ÙÙ‚ Binance WebSocket Ø§Ù„ÙÙˆØ±ÙŠ (!ticker@arr) Ù„Ø£Ø¹Ù„Ù‰ Ø³Ø±Ø¹Ø© Ù…Ù…ÙƒÙ†Ø©.
- ÙƒÙ„ Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øª Ù…Ø¨Ù†ÙŠØ© Ø¹Ù„Ù‰ Ù†Ù…Ø§Ø°Ø¬ ÙƒÙ…ÙŠØ© ØªÙ„ØªÙ‚Ø· Ø§Ù„ØªØ´ÙˆÙ‡Ø§Øª Ø§Ù„Ø¨Ù†ÙŠÙˆÙŠØ© Ù‚Ø¨Ù„ Ø§Ù„Ø¶Ø®.
"""

# =====================[ âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø­Ø±Ùƒ Ø§Ù„ÙƒÙ…ÙŠ ]=====================
CONFIG = {
    # Ù†ÙˆØ§ÙØ° Ø§Ù„ØªØ­Ù„ÙŠÙ„ (Ø¨Ø§Ù„Ø«ÙˆØ§Ù†ÙŠ/Ø§Ù„Ø¹ÙŠÙ†Ø§Øª)
    "WINDOW_SIZE": 180,                  # Ø·ÙˆÙ„ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ø²Ù…Ù†ÙŠØ© Ù„Ù„Ø£Ø³Ø¹Ø§Ø± ÙˆØ§Ù„Ø­Ø¬ÙˆÙ…
    "RETURNS_WINDOW": 120,               # Ù†Ø§ÙØ°Ø© Ø­Ø³Ø§Ø¨ Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ù„ÙˆØ¬ Ùˆ Ø§Ù„Ø¥Ù†ØªØ±ÙˆØ¨ÙŠØ§
    "IMBALANCE_WINDOW": 60,             # Ù†Ø§ÙØ°Ø© ØªÙˆØ§Ø²Ù† Ø§Ù„Ø¹Ø±Ø¶/Ø§Ù„Ø·Ù„Ø¨

    # Ø­ÙˆØ§Ø¬Ø² Ø¥Ø­ØµØ§Ø¦ÙŠØ©
    "MIN_24H_VOL": 20_000_000,          # ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ø£ØµÙˆÙ„ Ø°Ø§Øª Ø³ÙŠÙˆÙ„Ø© Ø¶Ø¹ÙŠÙØ©
    "HURST_MIN": 0.65,                  # Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ù‡ÙŠØ±Ø³Øª Ù„Ø§Ø¹ØªØ¨Ø§Ø± Ø³Ù„ÙˆÙƒ Ø§ØªØ¬Ø§Ù‡ÙŠ Ù‚ÙˆÙŠ
    "ENTROPY_DROP_RATIO": 0.18,         # Ù…Ù‚Ø¯Ø§Ø± Ø§Ù„Ø§Ù†Ø®ÙØ§Ø¶ Ø§Ù„Ù†Ø³Ø¨ÙŠ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ ÙÙŠ Ø§Ù„Ø¥Ù†ØªØ±ÙˆØ¨ÙŠØ§
    "KALMAN_RESIDUAL_Z": 2.6,           # Z-Score Ù„Ø¨Ù‚Ø§ÙŠØ§ Ø§Ù„ÙƒØ§Ù„Ù…Ø§Ù† Ù„Ø¥Ø¹Ù„Ø§Ù† ÙƒØ³Ø± Ù‡ÙŠÙƒÙ„ÙŠ
    "IMBALANCE_ACCEL_THRESHOLD": 0.12,  # ØªØ³Ø§Ø±Ø¹ ØªÙˆØ§Ø²Ù† Ø§Ù„Ø·Ù„Ø¨/Ø§Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨

    # Ø¨Ø§Ø±Ø§Ù…ØªØ±Ø§Øª Ø§Ù„ÙƒØ§Ù„Ù…Ø§Ù† (1D)
    "KALMAN_PROCESS_NOISE": 1e-3,
    "KALMAN_MEAS_NOISE": 2e-2,

    # Ø§Ù„ØªÙØ¹ÙŠÙ„/Ø§Ù„ØªØ¹Ø·ÙŠÙ„ Ù„ÙƒÙ„ Ø¥Ø´Ø§Ø±Ø© ÙƒÙ…ÙŠØ©
    "ENABLE_HURST_TREND": True,
    "ENABLE_ENTROPY_IMBALANCE": True,
    "ENABLE_KALMAN_BREAK": True,
    "ENABLE_IMBALANCE_ACCEL": True,

    # Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù‚Ø§ÙŠÙŠØ³ Ø§Ù„ØªØ±Ø§ÙƒÙ…ÙŠØ©
    "ENABLE_CUMULATIVE_RISE": True,
    "ENABLE_CUMULATIVE_DROP": True,
    "SHOW_ALERT_COUNTERS": True,

    # Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ø³ÙˆÙ‚
    "BTC_PROTECTION": True,
    "BTC_DUMP_PERCENT": -0.4,

    "LOG_FILE": "quantum_signals.csv",
}

# =====================[ ğŸ¨ ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„ØªÙŠØ±Ù…ÙŠÙ†Ø§Ù„ Ø§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠØ© ]=====================
class Term:
    PURPLE = "\033[95m"
    CYAN = "\033[96m"
    DARKCYAN = "\033[36m"
    BLUE = "\033[94m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    RED = "\033[91m"
    BOLD = "\033[1m"
    UNDERLINE = "\033[4m"
    END = "\033[0m"

    @staticmethod
    def print_banner():
        # ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø´Ø§Ø´Ø© Ø¨Ø·Ø±ÙŠÙ‚Ø© Ù…ØªÙˆØ§ÙÙ‚Ø© Ù…Ø¹ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ù†Ø¸Ù…Ø©
        print("\033c", end="")
        print(
            f"""{Term.PURPLE}{Term.BOLD}
        â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
        â•‘      QUANTUM FLOW SNIPER v6.0 (Institutional Quant Edition)    â•‘
        â•‘ [ Hurst | Shannon Entropy | Kalman Structural Break | OFI dÂ² ] â•‘
        â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        {Term.END}"""
        )


# =====================[ ğŸ§  Ø£Ø¯ÙˆØ§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠ ]=====================
@dataclass
class Kalman1D:
    process_noise: float
    measurement_noise: float
    state_estimate: float = 0.0
    covariance: float = 1.0
    initialized: bool = False

    def update(self, measurement: float) -> Tuple[float, float]:
        # ØªÙ‡ÙŠØ¦Ø© Ø£ÙˆÙ„ÙŠØ© Ù„Ø¶Ø¨Ø· Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© Ø¹Ù„Ù‰ Ø£ÙˆÙ„ Ù‚ÙŠÙ…Ø© Ø³Ø¹Ø±
        if not self.initialized:
            self.state_estimate = measurement
            self.covariance = 1.0
            self.initialized = True
            residual = 0.0
            return self.state_estimate, residual

        # Ù…Ø±Ø­Ù„Ø© Ø§Ù„ØªÙ†Ø¨Ø¤
        predicted_state = self.state_estimate
        predicted_cov = self.covariance + self.process_noise

        # Ù…Ø±Ø­Ù„Ø© Ø§Ù„ØªØµØ­ÙŠØ­ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø©
        kalman_gain = predicted_cov / (predicted_cov + self.measurement_noise)
        residual = measurement - predicted_state
        self.state_estimate = predicted_state + kalman_gain * residual
        self.covariance = (1 - kalman_gain) * predicted_cov
        return self.state_estimate, residual


def hurst_exponent(series: np.ndarray) -> float:
    """Ø­Ø³Ø§Ø¨ Hurst Ø¹Ø¨Ø± ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù†Ø·Ø§Ù‚ Ø§Ù„Ù…ÙØ¹Ø§Ø¯ Ø¶Ø¨Ø·Ù‡ (R/S)."""
    if series.size < 20:
        return 0.5
    lags = np.arange(2, min(40, series.size // 2))
    tau = [np.sqrt(np.std(np.subtract(series[lag:], series[:-lag]))) for lag in lags]
    with np.errstate(divide="ignore", invalid="ignore"):
        poly = np.polyfit(np.log(lags), np.log(tau), 1)
    return poly[0] if not np.isnan(poly[0]) else 0.5


def shannon_entropy_drop(returns: np.ndarray, bins: int = 20) -> Tuple[float, float]:
    if returns.size < 30:
        return 0.0, 0.0
    hist, _ = np.histogram(returns, bins=bins, density=True)
    hist = hist[hist > 0]
    if hist.size == 0:
        return 0.0, 0.0
    ent = shannon_entropy(hist)
    rolling_mean = float(np.mean(hist))
    return float(ent), rolling_mean


@dataclass
class MarketState:
    symbol: str
    prices: Deque[float] = field(default_factory=lambda: deque(maxlen=CONFIG["WINDOW_SIZE"]))
    returns: Deque[float] = field(default_factory=lambda: deque(maxlen=CONFIG["RETURNS_WINDOW"]))
    imbalance: Deque[float] = field(default_factory=lambda: deque(maxlen=CONFIG["IMBALANCE_WINDOW"]))
    kalman: Kalman1D = field(
        default_factory=lambda: Kalman1D(
            CONFIG["KALMAN_PROCESS_NOISE"], CONFIG["KALMAN_MEAS_NOISE"]
        )
    )
    last_timestamp: float = 0.0

    def update(self, price: float, bid_qty: float, ask_qty: float) -> Dict[str, float]:
        """ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø³Ù„Ø§Ø³Ù„ Ø§Ù„Ø²Ù…Ù†ÙŠØ© ÙˆØ¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª Ø§Ù„Ù…Ø­Ø¯Ø«Ø©."""
        metrics = {}
        self.prices.append(price)

        if len(self.prices) >= 2:
            ret = math.log(self.prices[-1] / self.prices[-2])
            self.returns.append(ret)

        total_depth = bid_qty + ask_qty
        imbalance_value = (bid_qty - ask_qty) / total_depth if total_depth > 0 else 0.0
        self.imbalance.append(imbalance_value)

        price_array = np.fromiter(self.prices, dtype=float)
        returns_array = np.fromiter(self.returns, dtype=float)
        imbalance_array = np.fromiter(self.imbalance, dtype=float)

        # Hurst
        metrics["hurst"] = hurst_exponent(price_array)

        # Entropy
        current_entropy, _ = shannon_entropy_drop(returns_array)
        metrics["entropy"] = current_entropy
        if len(returns_array) > 10:
            metrics["entropy_ema"] = float(pd_ema(returns_array, span=20)[-1])
        else:
            metrics["entropy_ema"] = current_entropy

        # Imbalance derivatives
        if imbalance_array.size >= 4:
            first_derivative = np.gradient(imbalance_array)[-1]
            second_derivative = np.gradient(np.gradient(imbalance_array))[-1]
        else:
            first_derivative = 0.0
            second_derivative = 0.0
        metrics["imbalance_d1"] = float(first_derivative)
        metrics["imbalance_d2"] = float(second_derivative)

        # Kalman residual
        _, residual = self.kalman.update(price)
        metrics["kalman_residual"] = residual

        # Momentum Ø¢Ø®Ø± 5 Ù†Ù‚Ø§Ø·
        metrics["momentum"] = (
            ((self.prices[-1] - self.prices[-5]) / self.prices[-5]) * 100
            if len(self.prices) >= 5
            else 0.0
        )

        return metrics


# ===============[ ğŸ“ˆ Ù…Ø¤Ø´Ø±Ø§Øª Ù…Ø³Ø§Ù†Ø¯Ø© Ø¹Ø§Ù„ÙŠØ© Ø§Ù„Ø³Ø±Ø¹Ø© ]=====================
def pd_ema(series: np.ndarray, span: int) -> np.ndarray:
    """Ø­Ø³Ø§Ø¨ EMA Ø³Ø±ÙŠØ¹ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… numpy (Ø¨Ø¯ÙˆÙ† pandas)."""
    alpha = 2 / (span + 1)
    ema = np.zeros_like(series)
    ema[0] = series[0]
    for i in range(1, len(series)):
        ema[i] = alpha * series[i] + (1 - alpha) * ema[i - 1]
    return ema


# =====================[ ğŸš€ Ø§Ù„ÙƒÙˆØ± Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ ]=====================
class QuantumSniper:
    def __init__(self):
        # ÙŠØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø·Ø§Ø¨ÙˆØ± Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø¯Ø§Ø®Ù„ Ø­Ù„Ù‚Ø© Ø§Ù„Ø­Ø¯Ø« Ø§Ù„Ù†Ø´Ø·Ø© Ù„Ø¶Ù…Ø§Ù† ØªÙˆØ§ÙÙ‚ Ø§Ù„Ø­Ù„Ù‚Ø©
        # (ØªÙØ§Ø¯ÙŠ Ø®Ø·Ø£ "Future attached to a different loop").
        self.msg_queue: asyncio.Queue | None = None
        self.market_states: Dict[str, MarketState] = {}
        self.alert_stats: Dict[str, Dict[str, Dict[str, float]]] = defaultdict(
            lambda: defaultdict(lambda: {"count": 0, "rise": 0.0, "drop": 0.0})
        )
        self.paused = False
        self.btc_trend = 0.0

    async def ws_listener(self):
        url = "wss://stream.binance.com:9443/ws/!ticker@arr"
        async with aiohttp.ClientSession() as session:
            async with session.ws_connect(url, heartbeat=60) as ws:
                async for msg in ws:
                    if msg.type == aiohttp.WSMsgType.TEXT:
                        data = json.loads(msg.data)
                        await self.msg_queue.put(data)

    async def market_analyzer(self):
        while True:
            tickers = await self.msg_queue.get()
            if not isinstance(tickers, list):
                continue
            for ticker in tickers:
                await self.process_ticker(ticker)

    def btc_guard(self, ticker):
        if ticker.get("s") != "BTCUSDT":
            return
        price = float(ticker["c"])
        open_price = float(ticker.get("o", price))
        self.btc_trend = ((price - open_price) / open_price) * 100
        if self.btc_trend < CONFIG["BTC_DUMP_PERCENT"]:
            if not self.paused:
                print(
                    f"\n{Term.RED}{Term.BOLD}â›” BTC CRASH DETECTED ({self.btc_trend:.2f}%) - HALTING SNIPER{Term.END}"
                )
            self.paused = True
        elif self.paused:
            print(f"\n{Term.GREEN}âœ… BTC STABILIZED - RESUMING{Term.END}")
            self.paused = False

    async def process_ticker(self, ticker):
        symbol = ticker.get("s")
        if not symbol or symbol.endswith("BUSD"):
            return

        self.btc_guard(ticker)
        if self.paused:
            return

        quote_vol = float(ticker.get("q", 0))
        if quote_vol < CONFIG["MIN_24H_VOL"]:
            return

        price = float(ticker["c"])
        bid_qty = float(ticker.get("B", 0.0))
        ask_qty = float(ticker.get("A", 0.0))

        state = self.market_states.setdefault(symbol, MarketState(symbol))
        metrics = state.update(price, bid_qty, ask_qty)

        # Ø¥Ø´Ø§Ø±Ø§Øª ÙƒÙ…ÙŠØ© Ù…Ø±ÙƒØ¨Ø©
        await self.evaluate_signals(symbol, price, metrics)

    async def evaluate_signals(self, symbol: str, price: float, m: Dict[str, float]):
        entropy_buffer = list(self.market_states[symbol].returns)
        entropy_arr = np.fromiter(entropy_buffer, dtype=float)
        previous_entropy = float(pd_ema(entropy_arr, span=20)[-2]) if len(entropy_arr) > 2 else m["entropy"]

        # 1) Ø§ØªØ¬Ø§Ù‡ÙŠØ© Ù‚ÙˆÙŠØ© ÙˆÙÙ‚ Hurst + Ø²Ø®Ù… Ø¥ÙŠØ¬Ø§Ø¨ÙŠ
        if (
            CONFIG["ENABLE_HURST_TREND"]
            and m["hurst"] > CONFIG["HURST_MIN"]
            and m["momentum"] > 0.25
        ):
            await self.trigger_alert(
                "ğŸ“ HURST PERSISTENCE",
                symbol,
                price,
                extra={
                    "H": m["hurst"],
                    "mom": m["momentum"],
                },
                color=Term.CYAN,
                change=m["momentum"],
            )

        # 2) Ø§Ù†Ù‡ÙŠØ§Ø± Ø¥Ù†ØªØ±ÙˆØ¨ÙŠØ§ + ØªØ³Ø§Ø±Ø¹ ØªÙˆØ§Ø²Ù† Ø¥ÙŠØ¬Ø§Ø¨ÙŠ (ØªØ²Ø§Ù…Ù† Ø­ÙŠØªØ§Ù†)
        entropy_drop = (
            (previous_entropy - m["entropy"]) / previous_entropy
            if previous_entropy > 0
            else 0.0
        )
        if (
            CONFIG["ENABLE_ENTROPY_IMBALANCE"]
            and entropy_drop >= CONFIG["ENTROPY_DROP_RATIO"]
            and m["imbalance_d2"] > 0
            and m["imbalance_d1"] > 0
        ):
            await self.trigger_alert(
                "ğŸ§  ENTROPY COLLAPSE",
                symbol,
                price,
                extra={
                    "Î”H": entropy_drop,
                    "âˆ‚I": m["imbalance_d1"],
                    "âˆ‚Â²I": m["imbalance_d2"],
                },
                color=Term.PURPLE,
                change=m["imbalance_d1"] * 100,
            )

        # 3) Ø¨Ù‚Ø§ÙŠØ§ ÙƒØ§Ù„Ù…Ø§Ù† Ù…Ø±ØªÙØ¹Ø© = ÙƒØ³Ø± Ù‡ÙŠÙƒÙ„ÙŠ Ù…ÙØ§Ø¬Ø¦
        if CONFIG["ENABLE_KALMAN_BREAK"]:
            residual_std = float(np.std(list(self.market_states[symbol].returns) or [0.0]))
            residual_std = residual_std if residual_std > 0 else 1e-6
            residual_z = m["kalman_residual"] / residual_std
            if abs(residual_z) >= CONFIG["KALMAN_RESIDUAL_Z"]:
                await self.trigger_alert(
                    "ğŸ›°ï¸ KALMAN STRUCTURAL BREAK",
                    symbol,
                    price,
                    extra={
                        "z_res": residual_z,
                        "res": m["kalman_residual"],
                    },
                    color=Term.YELLOW,
                    change=residual_z,
                )

        # 4) ØªØ³Ø§Ø±Ø¹ Ù…Ø´ØªÙ‚ Ø«Ø§Ù†ÙŠ Ù…ÙˆØ¬Ø¨ Ù„ØªÙˆØ§Ø²Ù† Ø§Ù„Ø¹Ø±Ø¶/Ø§Ù„Ø·Ù„Ø¨ (ØªØ¯ÙÙ‚ Ø£ÙˆØ§Ù…Ø± Ø­Ù‚ÙŠÙ‚ÙŠ)
        if (
            CONFIG["ENABLE_IMBALANCE_ACCEL"]
            and m["imbalance_d2"] > CONFIG["IMBALANCE_ACCEL_THRESHOLD"]
            and m["imbalance_d1"] > 0
        ):
            await self.trigger_alert(
                "âš¡ ORDERFLOW ACCEL",
                symbol,
                price,
                extra={
                    "âˆ‚I": m["imbalance_d1"],
                    "âˆ‚Â²I": m["imbalance_d2"],
                },
                color=Term.GREEN,
                change=m["imbalance_d2"] * 100,
            )

    def update_alert_stats(self, symbol: str, strategy: str, change: float):
        stats = self.alert_stats[symbol][strategy]
        stats["count"] += 1
        if CONFIG["ENABLE_CUMULATIVE_RISE"] and change > 0:
            stats["rise"] += change
        if CONFIG["ENABLE_CUMULATIVE_DROP"] and change < 0:
            stats["drop"] += abs(change)
        return stats

    async def trigger_alert(self, signal_type: str, symbol: str, price: float, extra: Dict[str, float], color: str, change: float):
        timestamp = time.strftime("%H:%M:%S")
        stats = self.update_alert_stats(symbol, signal_type, change)

        counter_info = f"#{int(stats['count'])}" if CONFIG["SHOW_ALERT_COUNTERS"] else ""
        rise_info = f"ğŸ”º{stats['rise']:.2f}%" if CONFIG["ENABLE_CUMULATIVE_RISE"] else ""
        drop_info = f"ğŸ”»{stats['drop']:.2f}%" if CONFIG["ENABLE_CUMULATIVE_DROP"] else ""
        stats_parts = [part for part in [rise_info, drop_info] if part]
        stats_text = " | ".join(stats_parts) if stats_parts else "N/A"
        symbol_display = f"{symbol} {counter_info} ({stats_text})".strip()

        # Ù†Øµ Ø±ÙŠØ§Ø¶ÙŠ Ù…Ø®ØªØµØ± Ø¨Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©
        extra_lines = " | ".join([f"{k}:{v:.3f}" for k, v in extra.items()]) if extra else ""

        print(f"{color}{Term.BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—{Term.END}")
        print(f"{color}â•‘ {signal_type:<28} | {symbol_display:<22} â° {timestamp} â•‘{Term.END}")
        print(f"{color}â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£{Term.END}")
        print(f"{color}â•‘ ğŸ’ Price: {price:<12} | ğŸ“ˆ Change: {change:+.3f}             â•‘{Term.END}")
        print(f"{color}â•‘ ğŸ“Š Metrics: {extra_lines:<44}â•‘{Term.END}")
        print(f"{color}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•{Term.END}")

        with open(CONFIG["LOG_FILE"], "a", newline="") as f:
            writer = csv.writer(f)
            row = [timestamp, symbol, signal_type, price, change] + [f"{k}:{v}" for k, v in extra.items()]
            writer.writerow(row)

    async def main(self):
        Term.print_banner()
        print(f"{Term.YELLOW}â³ Initializing Statistical Engines...{Term.END}")
        # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø·Ø§Ø¨ÙˆØ± Ø¨Ø¹Ø¯ Ø¨Ø¯Ø¡ Ø§Ù„Ø­Ù„Ù‚Ø© Ù„ØªÙˆØ­ÙŠØ¯ Ø§Ù„Ø­Ù„Ù‚Ø© Ø¨ÙŠÙ† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù‡Ø§Ù…
        self.msg_queue = asyncio.Queue()
        await asyncio.gather(self.ws_listener(), self.market_analyzer())


if __name__ == "__main__":
    try:
        if sys.platform == "win32":
            asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
        bot = QuantumSniper()
        asyncio.run(bot.main())
    except KeyboardInterrupt:
        print("\nğŸš« System Shutdown.")
    except RuntimeError as e:
        if "Event loop is closed" not in str(e):
            print(f"Runtime Error: {e}")
