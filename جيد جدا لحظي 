import asyncio
import json
import time
import math
import os
import csv
import sys
import aiohttp
from collections import deque, defaultdict
from dataclasses import dataclass, field
from typing import Dict, List, Tuple

# =====================[ âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø­Ø±Ùƒ Ø§Ù„ÙƒÙ…ÙŠ ]=====================

CONFIG = {
    "WINDOW_SIZE": 60,            # Ù†Ø§ÙØ°Ø© Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø¨Ø§Ù„Ø«ÙˆØ§Ù†ÙŠ (Ù„ØµÙ†Ø¹ Ø§Ù„Ù…ØªÙˆØ³Ø·Ø§Øª)
    "MIN_24H_VOL": 20_000_000,    # ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ø¹Ù…Ù„Ø§Øª Ø§Ù„Ù…ÙŠØªØ© (Ø£Ù‚Ù„ Ù…Ù† 10 Ù…Ù„ÙŠÙˆÙ†)
    
    # --- [ Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ§Øª Ø§Ù„Ø­Ø³Ø§Ø³ÙŠØ© ] ---
    "SIGMA_THRESHOLD": 1.5,       # (Z-Score) Ø§Ù„Ø­Ø³Ø§Ø³ÙŠØ© Ù„Ù„Ø´Ø°ÙˆØ° Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠ (3.5 = Ø­Ø¯Ø« Ù†Ø§Ø¯Ø± Ø¬Ø¯Ø§Ù‹)
    "ACCELERATION_FACTOR": 1.0,   # Ù…Ø¹Ø§Ù…Ù„ ØªØ³Ø§Ø±Ø¹ Ø§Ù„Ø³ÙŠÙˆÙ„Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨
    
    # --- [ ØªÙØ¹ÙŠÙ„/ØªØ¹Ø·ÙŠÙ„ Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª ] ---
    "ENABLE_SIGMA_EVENT": True,          # Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© "Ø§Ù„Ø­Ø¯Ø« Ø§Ù„Ù†ÙˆÙˆÙŠ"
    "ENABLE_VELOCITY_BREAKOUT": True,    # Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© "ÙƒØ³Ø± Ø§Ù„Ø²Ø®Ù…"
    "ENABLE_SILENT_ACCUMULATION": True,  # Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© "Ø§Ù„ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø®ÙÙŠ"
    
    # --- [ Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ø³ÙˆÙ‚ ] ---
    "BTC_PROTECTION": True,       # Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø´Ø±Ø§Ø¡ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø¨ÙŠØªÙƒÙˆÙŠÙ† ÙŠÙ†Ù‡Ø§Ø±
    "BTC_DUMP_PERCENT": -0.4,     # Ù†Ø³Ø¨Ø© Ù‡Ø¨ÙˆØ· Ø§Ù„Ø¨ÙŠØªÙƒÙˆÙŠÙ† ÙÙŠ Ø§Ù„Ø¯Ù‚ÙŠÙ‚Ø© Ø§Ù„ØªÙŠ ØªÙØ¹Ù„ Ø§Ù„Ø­Ù…Ø§ÙŠØ©
    
    "LOG_FILE": "quantum_signals.csv"
}

# =====================[ ğŸ¨ ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„ØªÙŠØ±Ù…ÙŠÙ†Ø§Ù„ Ø§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠØ© ]=====================

class Term:
    PURPLE = '\033[95m'
    CYAN = '\033[96m'
    DARKCYAN = '\033[36m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    END = '\033[0m'
    
    @staticmethod
    def print_banner():
        # ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø´Ø§Ø´Ø© Ø¨Ø·Ø±ÙŠÙ‚Ø© Ù…ØªÙˆØ§ÙÙ‚Ø© Ù…Ø¹ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ù†Ø¸Ù…Ø©
        print("\033c", end="")
        print(f"""{Term.PURPLE}{Term.BOLD}
        â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
        â•‘           QUANTUM FLOW SNIPER v5.1 (STATISTICAL)              â•‘
        â•‘       [ Z-Score Analysis | Momentum Velocity | BTC Guard ]    â•‘
        â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        {Term.END}""")

# =====================[ ğŸ§  Ø§Ù„Ù…Ø­Ø±Ùƒ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠ ]=====================

@dataclass
class MarketPulse:
    """ÙŠØ®Ø²Ù† Ù†Ø¨Ø¶ Ø§Ù„Ø³ÙˆÙ‚ Ù„ÙƒÙ„ Ø¹Ù…Ù„Ø© Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª"""
    symbol: str
    prices: deque = field(default_factory=lambda: deque(maxlen=CONFIG["WINDOW_SIZE"]))
    volumes: deque = field(default_factory=lambda: deque(maxlen=CONFIG["WINDOW_SIZE"]))
    last_accumulated_vol: float = 0.0
    
    def add_snapshot(self, price: float, accumulated_vol: float):
        # Ø­Ø³Ø§Ø¨ Ø­Ø¬Ù… Ø§Ù„ØªØ¯ÙÙ‚ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù„Ø­Ø¸Ø© (Delta)
        if self.last_accumulated_vol == 0:
            delta_vol = 0
        else:
            delta_vol = accumulated_vol - self.last_accumulated_vol
            # ØªØµØ­ÙŠØ­ ÙÙŠ Ø­Ø§Ù„Ø© Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„ÙŠÙˆÙ…
            if delta_vol < 0: delta_vol = 0 
            
        self.last_accumulated_vol = accumulated_vol
        
        self.prices.append(price)
        self.volumes.append(delta_vol)

    @property
    def is_ready(self):
        # Ù†Ø­ØªØ§Ø¬ Ø¨ÙŠØ§Ù†Ø§Øª ÙƒØ§ÙÙŠØ© Ù„ÙŠÙƒÙˆÙ† Ø§Ù„Ø§Ù†Ø­Ø±Ø§Ù Ø§Ù„Ù…Ø¹ÙŠØ§Ø±ÙŠ Ø¯Ù‚ÙŠÙ‚Ø§Ù‹
        return len(self.volumes) >= 20

    def calculate_statistics(self, current_vol_delta):
        """Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¯Ø±Ø¬Ø© Ø§Ù„Ù…Ø¹ÙŠØ§Ø±ÙŠØ© (Z-Score) Ù„Ø§ÙƒØªØ´Ø§Ù Ø§Ù„Ø´Ø°ÙˆØ°"""
        if not self.volumes: return 0, 0
        
        vol_list = list(self.volumes)
        mean = sum(vol_list) / len(vol_list)
        
        if mean == 0: return 0, 0
        
        # Ø­Ø³Ø§Ø¨ Ø§Ù„Ø§Ù†Ø­Ø±Ø§Ù Ø§Ù„Ù…Ø¹ÙŠØ§Ø±ÙŠ (Standard Deviation)
        variance = sum((x - mean) ** 2 for x in vol_list) / len(vol_list)
        std_dev = math.sqrt(variance)
        
        if std_dev == 0: return 0, 0
        
        # Ù…Ø¹Ø§Ø¯Ù„Ø© Z-Score: (Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© - Ø§Ù„Ù…ØªÙˆØ³Ø·) / Ø§Ù„Ø§Ù†Ø­Ø±Ø§Ù
        z_score = (current_vol_delta - mean) / std_dev
        
        return z_score, mean

    def get_price_momentum(self):
        if len(self.prices) < 5: return 0
        # Ù†Ø³Ø¨Ø© Ø§Ù„ØªØºÙŠØ± Ø®Ù„Ø§Ù„ Ø¢Ø®Ø± 5 Ø«ÙˆØ§Ù†ÙŠ
        start = self.prices[-5]
        end = self.prices[-1]
        return ((end - start) / start) * 100

# =====================[ ğŸš€ Ø§Ù„ÙƒÙˆØ± Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ ]=====================

class QuantumSniper:
    def __init__(self):
        self.base_ws = "wss://fstream.binance.com/ws/!ticker@arr"
        self.coins: Dict[str, MarketPulse] = {}
        # Ù‡Ø§Ù…: Ù„Ø§ ØªÙ‚Ù… Ø¨ØªÙ‡ÙŠØ¦Ø© Queue Ù‡Ù†Ø§ Ù„ØªØ¬Ù†Ø¨ Ù…Ø´Ø§ÙƒÙ„ Loop
        self.msg_queue = None 
        self.session = None
        self.btc_trend = 0.0
        self.paused = False
        
        # Ø¥Ø¹Ø¯Ø§Ø¯ Ù…Ù„Ù Ø§Ù„Ù„ÙˆØ¬
        if not os.path.exists(CONFIG["LOG_FILE"]):
            with open(CONFIG["LOG_FILE"], 'w', newline='') as f:
                writer = csv.writer(f)
                writer.writerow(["Time", "Symbol", "Type", "Price", "Z-Score", "Volume($)", "Change%"])

    async def ws_listener(self):
        """Ù…Ù‡Ù…ØªÙ‡ Ø§Ù„ÙˆØ­ÙŠØ¯Ø© Ø´ÙØ· Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙˆØ±Ù…ÙŠÙ‡Ø§ ÙÙŠ Ø§Ù„Ø·Ø§Ø¨ÙˆØ± Ø¨Ø£Ù‚ØµÙ‰ Ø³Ø±Ø¹Ø©"""
        while True:
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.ws_connect(self.base_ws) as ws:
                        print(f"{Term.GREEN}âœ“ Connected to Binance Neural Network...{Term.END}")
                        async for msg in ws:
                            if self.msg_queue:
                                await self.msg_queue.put(json.loads(msg.data))
            except Exception as e:
                print(f"{Term.RED}âš ï¸ Network Error: {e}{Term.END}")
                await asyncio.sleep(2)

    async def market_analyzer(self):
        """Ø§Ù„Ø¹Ù‚Ù„ Ø§Ù„Ù…Ø¯Ø¨Ø±: ÙŠØ¹Ø§Ù„Ø¬ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø±ÙŠØ§Ø¶ÙŠØ§Ù‹"""
        print(f"{Term.CYAN}âš¡ Analyzer Engine Started (Waiting for buffer)...{Term.END}")
        
        while True:
            if not self.msg_queue:
                await asyncio.sleep(0.1)
                continue
                
            data = await self.msg_queue.get()
            
            try:
                # ØªØ­Ù„ÙŠÙ„ Ø³Ø±ÙŠØ¹ Ù„Ù„Ø¨ÙŠØªÙƒÙˆÙŠÙ† Ø£ÙˆÙ„Ø§Ù‹ (Global Trend)
                btc_data = next((x for x in data if x['s'] == 'BTCUSDT'), None)
                if btc_data:
                    await self.update_btc_status(btc_data)

                # Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø³ÙˆÙ‚ ÙŠÙ†Ù‡Ø§Ø±ØŒ ØªÙˆÙ‚Ù Ù…Ø¤Ù‚ØªØ§Ù‹
                if self.paused and CONFIG["BTC_PROTECTION"]:
                    continue

                # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ø¹Ù…Ù„Ø§Øª
                tasks = []
                for ticker in data:
                    symbol = ticker['s']
                    if not symbol.endswith('USDT'): continue
                    if 'BTC' in symbol and symbol != 'BTCUSDT': continue
                    
                    # ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø¹Ù…Ù„Ø© Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø¬Ø¯ÙŠØ¯Ø©
                    if symbol not in self.coins:
                        # ÙÙ„ØªØ± Ø§Ù„Ø­Ø¬Ù… Ø§Ù„ÙŠÙˆÙ…ÙŠ
                        if float(ticker['q']) < CONFIG["MIN_24H_VOL"]: continue
                        self.coins[symbol] = MarketPulse(symbol)

                    tasks.append(self.process_coin(self.coins[symbol], ticker))
                
                if tasks:
                    await asyncio.gather(*tasks)
            
            except Exception as e:
                print(f"Error in Analyzer: {e}")
            finally:
                self.msg_queue.task_done()

    async def update_btc_status(self, ticker):
        """Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø¨ÙŠØªÙƒÙˆÙŠÙ† Ø§Ù„Ø¹Ø§Ù…"""
        pulse = self.coins.get('BTCUSDT')
        if not pulse: 
            self.coins['BTCUSDT'] = MarketPulse('BTCUSDT')
            return
            
        price = float(ticker['c'])
        vol = float(ticker['q'])
        pulse.add_snapshot(price, vol)
        
        if len(pulse.prices) > 10:
            start_price = pulse.prices[0]
            self.btc_trend = ((price - start_price) / start_price) * 100
            
            if self.btc_trend < CONFIG["BTC_DUMP_PERCENT"]:
                if not self.paused:
                    print(f"\n{Term.RED}{Term.BOLD}â›” BTC CRASH DETECTED ({self.btc_trend:.2f}%) - HALTING SNIPER{Term.END}")
                self.paused = True
            else:
                if self.paused:
                    print(f"\n{Term.GREEN}âœ… BTC STABILIZED - RESUMING{Term.END}")
                self.paused = False

    async def process_coin(self, pulse: MarketPulse, ticker):
        """ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¹Ù…Ù„Ø© Ø§Ù„ÙˆØ§Ø­Ø¯Ø©"""
        current_price = float(ticker['c'])
        accumulated_vol = float(ticker['q'])
        
        # Ø­Ø³Ø§Ø¨ Ø§Ù„Ø­Ø¬Ù… Ø§Ù„Ù„Ø­Ø¸ÙŠ Ù‚Ø¨Ù„ Ø§Ù„ØªØ­Ø¯ÙŠØ«
        prev_vol = pulse.last_accumulated_vol
        if prev_vol == 0:
            pulse.add_snapshot(current_price, accumulated_vol)
            return

        delta_vol = accumulated_vol - prev_vol
        if delta_vol < 0: delta_vol = 0 # Reset case
        
        # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ§Ø±ÙŠØ®ÙŠØ©
        pulse.add_snapshot(current_price, accumulated_vol)

        if not pulse.is_ready: return

        # --- [ Ø§Ù„Ù…Ù†Ø·Ù‚ Ø§Ù„Ø®Ø§Ø±Ù‚: Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠ ] ---
        
        z_score, mean_vol = pulse.calculate_statistics(delta_vol)
        price_momentum = pulse.get_price_momentum()
        
        # 1. Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© "Ø§Ù„Ø­Ø¯Ø« Ø§Ù„Ù†ÙˆÙˆÙŠ" (Sigma Event)
        if CONFIG["ENABLE_SIGMA_EVENT"] and z_score > CONFIG["SIGMA_THRESHOLD"] and price_momentum > 0.2:
            await self.trigger_alert(
                "â˜¢ï¸ STATISTICAL ANOMALY", 
                pulse.symbol, current_price, z_score, delta_vol, price_momentum, Term.RED
            )
            
        # 2. Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© "Ø§Ù„ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø®ÙÙŠ" (Silent Accumulation)
        elif CONFIG["ENABLE_SILENT_ACCUMULATION"] and z_score > 2.5 and -0.05 <= price_momentum <= 0.05:
            await self.trigger_alert(
                "ğŸ³ SILENT ACCUMULATION", 
                pulse.symbol, current_price, z_score, delta_vol, price_momentum, Term.PURPLE
            )

        # 3. Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© "ÙƒØ³Ø± Ø§Ù„Ø²Ø®Ù…" (Velocity Breakout)
        vol_acceleration = delta_vol / mean_vol if mean_vol > 0 else 0
        if CONFIG["ENABLE_VELOCITY_BREAKOUT"] and vol_acceleration > CONFIG["ACCELERATION_FACTOR"] * 2 and price_momentum > 0.5:
            await self.trigger_alert(
                "ğŸš€ VELOCITY BREAKOUT", 
                pulse.symbol, current_price, z_score, delta_vol, price_momentum, Term.YELLOW
            )

    async def trigger_alert(self, signal_type, symbol, price, z, vol, change, color):
        timestamp = time.strftime("%H:%M:%S")
        
        # ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø­Ø¬Ù…
        vol_str = f"${vol/1000:.1f}K" if vol < 1000000 else f"${vol/1000000:.2f}M"
        
        # Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„ØªÙ†Ø¨ÙŠÙ‡
        print(f"{color}{Term.BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—{Term.END}")
        print(f"{color}â•‘ {signal_type:<25} | {symbol:<10} â° {timestamp}    â•‘{Term.END}")
        print(f"{color}â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£{Term.END}")
        print(f"{color}â•‘ ğŸ“Š Z-Score: {z:.2f}Ïƒ (Rare!)     ğŸ’ Price: {price}       â•‘{Term.END}")
        print(f"{color}â•‘ ğŸŒŠ Vol 1s:  {vol_str:<10}     ğŸ“ˆ Change: {change:+.2f}%       â•‘{Term.END}")
        print(f"{color}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•{Term.END}")
        
        # Ø­ÙØ¸ ÙÙŠ Ù…Ù„Ù CSV
        with open(CONFIG["LOG_FILE"], 'a', newline='') as f:
            writer = csv.writer(f)
            writer.writerow([timestamp, symbol, signal_type, price, round(z, 2), round(vol, 2), round(change, 2)])

    async def main(self):
        Term.print_banner()
        print(f"{Term.YELLOW}â³ Calibrating statistical models (Collecting History)...{Term.END}")
        
        # Ø§Ù„Ø­Ù„ Ø§Ù„Ø¬Ø°Ø±ÙŠ Ù„Ù„Ù…Ø´ÙƒÙ„Ø©: Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø·Ø§Ø¨ÙˆØ± Ø¯Ø§Ø®Ù„ Ø§Ù„Ø­Ù„Ù‚Ø© Ø§Ù„Ù†Ø´Ø·Ø© Ù‡Ù†Ø§
        self.msg_queue = asyncio.Queue()
        
        # ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø¨Ø´ÙƒÙ„ Ù…ØªÙˆØ§Ø²ÙŠ
        await asyncio.gather(
            self.ws_listener(),
            self.market_analyzer()
        )

if __name__ == "__main__":
    try:
        # Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªÙˆØ§ÙÙ‚ÙŠØ© Ù„Ù†Ø¸Ø§Ù… Pydroid Ùˆ Windows
        if sys.platform == 'win32':
            asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
            
        bot = QuantumSniper()
        asyncio.run(bot.main())
    except KeyboardInterrupt:
        print("\nğŸš« System Shutdown.")
    except RuntimeError as e:
        # ØªØ¬Ø§Ù‡Ù„ Ø£Ø®Ø·Ø§Ø¡ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø­Ù„Ù‚Ø© Ø§Ù„Ù…Ø¹Ø±ÙˆÙØ© ÙÙŠ Pydroid
        if "Event loop is closed" not in str(e):
            print(f"Runtime Error: {e}")