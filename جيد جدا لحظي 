import asyncio
import json
import time
import math
import os
import csv
import sys
import aiohttp
from collections import deque, defaultdict
from dataclasses import dataclass, field
from typing import Dict, List, Tuple

# =====================[ โ๏ธ ุฅุนุฏุงุฏุงุช ุงููุญุฑู ุงูููู ]=====================

CONFIG = {
    "WINDOW_SIZE": 60,            # ูุงูุฐุฉ ุงูุชุญููู ุจุงูุซูุงูู (ูุตูุน ุงููุชูุณุทุงุช)
    "MIN_24H_VOL": 20_000_000,    # ุชุฌุงูู ุงูุนููุงุช ุงูููุชุฉ (ุฃูู ูู 10 ููููู)
    
    # --- [ ุฎูุงุฑุฒููุงุช ุงูุญุณุงุณูุฉ ] ---
    "SIGMA_THRESHOLD": 1.5,       # (Z-Score) ุงูุญุณุงุณูุฉ ููุดุฐูุฐ ุงูุฅุญุตุงุฆู (3.5 = ุญุฏุซ ูุงุฏุฑ ุฌุฏุงู)
    "ACCELERATION_FACTOR": 1.0,   # ูุนุงูู ุชุณุงุฑุน ุงูุณูููุฉ ุงููุทููุจ
    
    # --- [ ุชูุนูู/ุชุนุทูู ุงูุงุณุชุฑุงุชูุฌูุงุช ] ---
    "ENABLE_SIGMA_EVENT": True,          # ุงุณุชุฑุงุชูุฌูุฉ "ุงูุญุฏุซ ุงููููู"
    "ENABLE_VELOCITY_BREAKOUT": True,    # ุงุณุชุฑุงุชูุฌูุฉ "ูุณุฑ ุงูุฒุฎู"
    "ENABLE_SILENT_ACCUMULATION": True,  # ุงุณุชุฑุงุชูุฌูุฉ "ุงูุชุฌููุน ุงููุฎูู"

    # --- [ ุชูุนูู/ุชุนุทูู ุงูููุงุณุงุช ุงูุชุฑุงูููุฉ ] ---
    "ENABLE_CUMULATIVE_RISE": True,      # ุญุณุงุจ ูุณุจุฉ ุงูุงุฑุชูุงุน ุงูุชุฑุงูููุฉ
    "ENABLE_CUMULATIVE_DROP": True,      # ุญุณุงุจ ูุณุจุฉ ุงูุงูุฎูุงุถ ุงูุชุฑุงูููุฉ
    "SHOW_ALERT_COUNTERS": True,         # ุฅุธูุงุฑ ุนุฏุฏ ูุฑุงุช ุชูุฑุงุฑ ุงูุชูุจูู
    
    # --- [ ุญูุงูุฉ ุงูุณูู ] ---
    "BTC_PROTECTION": True,       # ุฅููุงู ุงูุดุฑุงุก ุฅุฐุง ูุงู ุงูุจูุชูููู ูููุงุฑ
    "BTC_DUMP_PERCENT": -0.4,     # ูุณุจุฉ ูุจูุท ุงูุจูุชูููู ูู ุงูุฏูููุฉ ุงูุชู ุชูุนู ุงูุญูุงูุฉ
    
    "LOG_FILE": "quantum_signals.csv"
}

# =====================[ ๐จ ูุงุฌูุฉ ุงูุชูุฑูููุงู ุงูุงุญุชุฑุงููุฉ ]=====================

class Term:
    PURPLE = '\033[95m'
    CYAN = '\033[96m'
    DARKCYAN = '\033[36m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    END = '\033[0m'
    
    @staticmethod
    def print_banner():
        # ุชูุธูู ุงูุดุงุดุฉ ุจุทุฑููุฉ ูุชูุงููุฉ ูุน ุฌููุน ุงูุฃูุธูุฉ
        print("\033c", end="")
        print(f"""{Term.PURPLE}{Term.BOLD}
        โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
        โ           QUANTUM FLOW SNIPER v5.1 (STATISTICAL)              โ
        โ       [ Z-Score Analysis | Momentum Velocity | BTC Guard ]    โ
        โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
        {Term.END}""")

# =====================[ ๐ง ุงููุญุฑู ุงูุฅุญุตุงุฆู ]=====================

@dataclass
class MarketPulse:
    """ูุฎุฒู ูุจุถ ุงูุณูู ููู ุนููุฉ ูุญุณุงุจ ุงูุฅุญุตุงุฆูุงุช"""
    symbol: str
    prices: deque = field(default_factory=lambda: deque(maxlen=CONFIG["WINDOW_SIZE"]))
    volumes: deque = field(default_factory=lambda: deque(maxlen=CONFIG["WINDOW_SIZE"]))
    last_accumulated_vol: float = 0.0
    
    def add_snapshot(self, price: float, accumulated_vol: float):
        # ุญุณุงุจ ุญุฌู ุงูุชุฏูู ูู ูุฐู ุงููุญุธุฉ (Delta)
        if self.last_accumulated_vol == 0:
            delta_vol = 0
        else:
            delta_vol = accumulated_vol - self.last_accumulated_vol
            # ุชุตุญูุญ ูู ุญุงูุฉ ุฅุนุงุฏุฉ ุชุนููู ุงูููู
            if delta_vol < 0: delta_vol = 0 
            
        self.last_accumulated_vol = accumulated_vol
        
        self.prices.append(price)
        self.volumes.append(delta_vol)

    @property
    def is_ready(self):
        # ูุญุชุงุฌ ุจูุงูุงุช ูุงููุฉ ููููู ุงูุงูุญุฑุงู ุงููุนูุงุฑู ุฏูููุงู
        return len(self.volumes) >= 20

    def calculate_statistics(self, current_vol_delta):
        """ุญุณุงุจ ุงูุฏุฑุฌุฉ ุงููุนูุงุฑูุฉ (Z-Score) ูุงูุชุดุงู ุงูุดุฐูุฐ"""
        if not self.volumes: return 0, 0
        
        vol_list = list(self.volumes)
        mean = sum(vol_list) / len(vol_list)
        
        if mean == 0: return 0, 0
        
        # ุญุณุงุจ ุงูุงูุญุฑุงู ุงููุนูุงุฑู (Standard Deviation)
        variance = sum((x - mean) ** 2 for x in vol_list) / len(vol_list)
        std_dev = math.sqrt(variance)
        
        if std_dev == 0: return 0, 0
        
        # ูุนุงุฏูุฉ Z-Score: (ุงููููุฉ ุงูุญุงููุฉ - ุงููุชูุณุท) / ุงูุงูุญุฑุงู
        z_score = (current_vol_delta - mean) / std_dev
        
        return z_score, mean

    def get_price_momentum(self):
        if len(self.prices) < 5: return 0
        # ูุณุจุฉ ุงูุชุบูุฑ ุฎูุงู ุขุฎุฑ 5 ุซูุงูู
        start = self.prices[-5]
        end = self.prices[-1]
        return ((end - start) / start) * 100

# =====================[ ๐ ุงูููุฑ ุงูุฑุฆูุณู ]=====================

class QuantumSniper:
    def __init__(self):
        self.base_ws = "wss://fstream.binance.com/ws/!ticker@arr"
        self.coins: Dict[str, MarketPulse] = {}
        # ูุงู: ูุง ุชูู ุจุชููุฆุฉ Queue ููุง ูุชุฌูุจ ูุดุงูู Loop
        self.msg_queue = None 
        self.session = None
        self.btc_trend = 0.0
        self.paused = False
        self.alert_stats: Dict[str, Dict[str, Dict[str, float]]] = defaultdict(
            lambda: defaultdict(lambda: {"count": 0, "rise": 0.0, "drop": 0.0})
        )
        
        # ุฅุนุฏุงุฏ ููู ุงูููุฌ
        if not os.path.exists(CONFIG["LOG_FILE"]):
            with open(CONFIG["LOG_FILE"], 'w', newline='') as f:
                writer = csv.writer(f)
                writer.writerow(["Time", "Symbol", "Type", "Price", "Z-Score", "Volume($)", "Change%"])

    async def ws_listener(self):
        """ูููุชู ุงููุญูุฏุฉ ุดูุท ุงูุจูุงูุงุช ูุฑูููุง ูู ุงูุทุงุจูุฑ ุจุฃูุตู ุณุฑุนุฉ"""
        while True:
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.ws_connect(self.base_ws) as ws:
                        print(f"{Term.GREEN}โ Connected to Binance Neural Network...{Term.END}")
                        async for msg in ws:
                            if self.msg_queue:
                                await self.msg_queue.put(json.loads(msg.data))
            except Exception as e:
                print(f"{Term.RED}โ๏ธ Network Error: {e}{Term.END}")
                await asyncio.sleep(2)

    async def market_analyzer(self):
        """ุงูุนูู ุงููุฏุจุฑ: ูุนุงูุฌ ุงูุจูุงูุงุช ุฑูุงุถูุงู"""
        print(f"{Term.CYAN}โก Analyzer Engine Started (Waiting for buffer)...{Term.END}")
        
        while True:
            if not self.msg_queue:
                await asyncio.sleep(0.1)
                continue
                
            data = await self.msg_queue.get()
            
            try:
                # ุชุญููู ุณุฑูุน ููุจูุชูููู ุฃููุงู (Global Trend)
                btc_data = next((x for x in data if x['s'] == 'BTCUSDT'), None)
                if btc_data:
                    await self.update_btc_status(btc_data)

                # ุฅุฐุง ูุงู ุงูุณูู ูููุงุฑุ ุชููู ูุคูุชุงู
                if self.paused and CONFIG["BTC_PROTECTION"]:
                    continue

                # ูุนุงูุฌุฉ ุจุงูู ุงูุนููุงุช
                tasks = []
                for ticker in data:
                    symbol = ticker['s']
                    if not symbol.endswith('USDT'): continue
                    if 'BTC' in symbol and symbol != 'BTCUSDT': continue
                    
                    # ุชููุฆุฉ ุงูุนููุฉ ุฅุฐุง ูุงูุช ุฌุฏูุฏุฉ
                    if symbol not in self.coins:
                        # ููุชุฑ ุงูุญุฌู ุงููููู
                        if float(ticker['q']) < CONFIG["MIN_24H_VOL"]: continue
                        self.coins[symbol] = MarketPulse(symbol)

                    tasks.append(self.process_coin(self.coins[symbol], ticker))
                
                if tasks:
                    await asyncio.gather(*tasks)
            
            except Exception as e:
                print(f"Error in Analyzer: {e}")
            finally:
                self.msg_queue.task_done()

    async def update_btc_status(self, ticker):
        """ูุฑุงูุจุฉ ุงุชุฌุงู ุงูุจูุชูููู ุงูุนุงู"""
        pulse = self.coins.get('BTCUSDT')
        if not pulse: 
            self.coins['BTCUSDT'] = MarketPulse('BTCUSDT')
            return
            
        price = float(ticker['c'])
        vol = float(ticker['q'])
        pulse.add_snapshot(price, vol)
        
        if len(pulse.prices) > 10:
            start_price = pulse.prices[0]
            self.btc_trend = ((price - start_price) / start_price) * 100
            
            if self.btc_trend < CONFIG["BTC_DUMP_PERCENT"]:
                if not self.paused:
                    print(f"\n{Term.RED}{Term.BOLD}โ BTC CRASH DETECTED ({self.btc_trend:.2f}%) - HALTING SNIPER{Term.END}")
                self.paused = True
            else:
                if self.paused:
                    print(f"\n{Term.GREEN}โ BTC STABILIZED - RESUMING{Term.END}")
                self.paused = False

    async def process_coin(self, pulse: MarketPulse, ticker):
        """ุชุญููู ุงูุนููุฉ ุงููุงุญุฏุฉ"""
        current_price = float(ticker['c'])
        accumulated_vol = float(ticker['q'])
        
        # ุญุณุงุจ ุงูุญุฌู ุงููุญุธู ูุจู ุงูุชุญุฏูุซ
        prev_vol = pulse.last_accumulated_vol
        if prev_vol == 0:
            pulse.add_snapshot(current_price, accumulated_vol)
            return

        delta_vol = accumulated_vol - prev_vol
        if delta_vol < 0: delta_vol = 0 # Reset case
        
        # ุชุญุฏูุซ ุงูุจูุงูุงุช ุงูุชุงุฑูุฎูุฉ
        pulse.add_snapshot(current_price, accumulated_vol)

        if not pulse.is_ready: return

        # --- [ ุงูููุทู ุงูุฎุงุฑู: ุงูุชุญููู ุงูุฅุญุตุงุฆู ] ---
        
        z_score, mean_vol = pulse.calculate_statistics(delta_vol)
        price_momentum = pulse.get_price_momentum()
        
        # 1. ุงุณุชุฑุงุชูุฌูุฉ "ุงูุญุฏุซ ุงููููู" (Sigma Event)
        if CONFIG["ENABLE_SIGMA_EVENT"] and z_score > CONFIG["SIGMA_THRESHOLD"] and price_momentum > 0.2:
            await self.trigger_alert(
                "โข๏ธ STATISTICAL ANOMALY", 
                pulse.symbol, current_price, z_score, delta_vol, price_momentum, Term.RED
            )
            
        # 2. ุงุณุชุฑุงุชูุฌูุฉ "ุงูุชุฌููุน ุงููุฎูู" (Silent Accumulation)
        elif CONFIG["ENABLE_SILENT_ACCUMULATION"] and z_score > 2.5 and -0.05 <= price_momentum <= 0.05:
            await self.trigger_alert(
                "๐ณ SILENT ACCUMULATION", 
                pulse.symbol, current_price, z_score, delta_vol, price_momentum, Term.PURPLE
            )

        # 3. ุงุณุชุฑุงุชูุฌูุฉ "ูุณุฑ ุงูุฒุฎู" (Velocity Breakout)
        vol_acceleration = delta_vol / mean_vol if mean_vol > 0 else 0
        if CONFIG["ENABLE_VELOCITY_BREAKOUT"] and vol_acceleration > CONFIG["ACCELERATION_FACTOR"] * 2 and price_momentum > 0.5:
            await self.trigger_alert(
                "๐ VELOCITY BREAKOUT", 
                pulse.symbol, current_price, z_score, delta_vol, price_momentum, Term.YELLOW
            )

    def update_alert_stats(self, symbol: str, strategy: str, change: float):
        stats = self.alert_stats[symbol][strategy]
        stats["count"] += 1

        if CONFIG["ENABLE_CUMULATIVE_RISE"] and change > 0:
            stats["rise"] += change

        if CONFIG["ENABLE_CUMULATIVE_DROP"] and change < 0:
            stats["drop"] += abs(change)

        return stats

    async def trigger_alert(self, signal_type, symbol, price, z, vol, change, color):
        timestamp = time.strftime("%H:%M:%S")

        stats = self.update_alert_stats(symbol, signal_type, change)

        # ุชูุณูู ุงูุญุฌู
        vol_str = f"${vol/1000:.1f}K" if vol < 1000000 else f"${vol/1000000:.2f}M"

        # ุชุฌููุฒ ูุนูููุงุช ุงูุฅุญุตุงุกุงุช ุงูุชุฑุงูููุฉ
        counter_info = f"#{int(stats['count'])}" if CONFIG["SHOW_ALERT_COUNTERS"] else ""
        rise_info = f"๐บ{stats['rise']:.2f}%" if CONFIG["ENABLE_CUMULATIVE_RISE"] else ""
        drop_info = f"๐ป{stats['drop']:.2f}%" if CONFIG["ENABLE_CUMULATIVE_DROP"] else ""
        stats_parts = [part for part in [rise_info, drop_info] if part]
        stats_text = " | ".join(stats_parts) if stats_parts else "N/A"
        symbol_display = f"{symbol} {counter_info} ({stats_text})".strip()

        # ุทุจุงุนุฉ ุงูุชูุจูู
        print(f"{color}{Term.BOLD}โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ{Term.END}")
        print(f"{color}โ {signal_type:<25} | {symbol_display:<25} โฐ {timestamp} โ{Term.END}")
        print(f"{color}โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโฃ{Term.END}")
        print(f"{color}โ ๐ Z-Score: {z:.2f}ฯ (Rare!)     ๐ Price: {price}       โ{Term.END}")
        print(f"{color}โ ๐ Vol 1s:  {vol_str:<10}     ๐ Change: {change:+.2f}%       โ{Term.END}")
        print(f"{color}โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ{Term.END}")

        # ุญูุธ ูู ููู CSV
        with open(CONFIG["LOG_FILE"], 'a', newline='') as f:
            writer = csv.writer(f)
            writer.writerow([timestamp, symbol, signal_type, price, round(z, 2), round(vol, 2), round(change, 2)])

    async def main(self):
        Term.print_banner()
        print(f"{Term.YELLOW}โณ Calibrating statistical models (Collecting History)...{Term.END}")
        
        # ุงูุญู ุงูุฌุฐุฑู ูููุดููุฉ: ุฅูุดุงุก ุงูุทุงุจูุฑ ุฏุงุฎู ุงูุญููุฉ ุงููุดุทุฉ ููุง
        self.msg_queue = asyncio.Queue()
        
        # ุชุดุบูู ุงูุนูููุงุช ุจุดูู ูุชูุงุฒู
        await asyncio.gather(
            self.ws_listener(),
            self.market_analyzer()
        )

if __name__ == "__main__":
    try:
        # ุฅุนุฏุงุฏุงุช ุงูุชูุงูููุฉ ููุธุงู Pydroid ู Windows
        if sys.platform == 'win32':
            asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
            
        bot = QuantumSniper()
        asyncio.run(bot.main())
    except KeyboardInterrupt:
        print("\n๐ซ System Shutdown.")
    except RuntimeError as e:
        # ุชุฌุงูู ุฃุฎุทุงุก ุฅุบูุงู ุงูุญููุฉ ุงููุนุฑููุฉ ูู Pydroid
        if "Event loop is closed" not in str(e):
            print(f"Runtime Error: {e}")